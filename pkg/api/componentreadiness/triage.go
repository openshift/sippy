package componentreadiness

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"slices"
	"strings"
	"time"

	"github.com/andygrunwald/go-jira"
	sippyapi "github.com/openshift/sippy/pkg/api"
	"github.com/openshift/sippy/pkg/api/componentreadiness/utils"
	"github.com/openshift/sippy/pkg/apis/api/componentreport"
	"github.com/openshift/sippy/pkg/apis/api/componentreport/crview"
	v1 "github.com/openshift/sippy/pkg/apis/sippy/v1"
	"github.com/openshift/sippy/pkg/db"
	"github.com/openshift/sippy/pkg/db/models"
	"github.com/openshift/sippy/pkg/db/query"
	log "github.com/sirupsen/logrus"
	"gorm.io/gorm"
)

func GetTriage(dbc *db.DB, id int, req *http.Request) (*models.Triage, error) {
	existingTriage := &models.Triage{}
	res := dbc.DB.Preload("Bug").Preload("Regressions").First(existingTriage, id)
	if res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		log.WithError(res.Error).Errorf("error looking up existing triage record: %d", id)
	}
	injectHATEOASLinks(existingTriage, sippyapi.GetBaseURL(req))
	return existingTriage, res.Error
}

func ListTriages(dbc *db.DB, req *http.Request) ([]models.Triage, error) {
	var triages []models.Triage
	var err error
	triages, err = query.ListTriages(dbc)
	for i := range triages {
		injectHATEOASLinks(&triages[i], sippyapi.GetBaseURL(req))
	}
	return triages, err
}

// validateTriage ensures the Triage record coming into the API appears valid. Small
// changes in logic for create vs update are controlled by the update param.
func validateTriage(triage models.Triage, update bool) error {
	create := !update
	if create && triage.ID > 0 {
		return fmt.Errorf("cannot specify an id for a new triage record, one will be autogenerated")
	}
	if update && triage.ID == 0 {
		return fmt.Errorf("must specify an id for a triage record update")
	}
	if triage.URL == "" {
		return fmt.Errorf("url is required for a triage record")
	}
	if !models.ValidTriageType(triage.Type) {
		return fmt.Errorf("invalid triage type: %s", triage.Type)
	}

	return nil
}

func CreateTriage(dbc *gorm.DB, jiraClient *jira.Client, triage models.Triage, req *http.Request) (models.Triage, error) {
	err := validateTriage(triage, false)
	if err != nil {
		log.WithError(err).Error("error validating triage record")
		return triage, err
	}
	// zero out the timestamps, you shouldn't be specifying them, but it's not worth erroring a request over
	triage.CreatedAt = time.Time{}
	triage.UpdatedAt = time.Time{}

	err = linkRegressions(dbc, &triage)
	if err != nil {
		return triage, err
	}

	// If we have a bug in the db matching the url we were given, link them up now.
	// If not, this should be handled later during the next fetchdata cron job.
	var bug models.Bug
	res := dbc.Where("url = ?", triage.URL).First(&bug)
	switch {
	case res.Error != nil && !errors.Is(res.Error, gorm.ErrRecordNotFound):
		log.WithError(res.Error).Errorf("unexpected error looking up bug: %s", triage.URL)
		return triage, res.Error
	case res.Error == nil:
		triage.Bug = &bug
		triage.BugID = &bug.ID
	}

	res = dbc.Create(&triage)
	if res.Error != nil {
		log.WithError(res.Error).Error("error creating triage record")
		return triage, res.Error
	}
	log.WithField("triageID", triage.ID).Info("triage record created")
	injectHATEOASLinks(&triage, sippyapi.GetBaseURL(req))
	err = reportJiraUsedForTriage(jiraClient, triage, req)
	if err != nil {
		log.WithError(err).Error("error reporting jira used for triage")
		return triage, err
	}
	return triage, nil
}

const jiraPrefix = "https://issues.redhat.com/browse/"

func reportJiraUsedForTriage(jiraClient *jira.Client, triage models.Triage, req *http.Request) error {
	logger := log.WithField("triageID", triage.ID)
	logger.Info("reporting jira used for triage")
	// No jiraClient will be provided in e2e testing
	if jiraClient == nil {
		logger.Warn("no jira client provided, will not comment link to Triage entry")
		return nil
	}

	if !strings.HasPrefix(triage.URL, jiraPrefix) {
		logger.Warnf("URL (%s) is not a Jira card, cannot comment", triage.URL)
		return nil
	}
	jiraCard := strings.TrimPrefix(triage.URL, jiraPrefix)
	if !strings.HasPrefix(jiraCard, "OCPBUGS") {
		logger.Warnf("URL (%s) is not an OCPBUGS card, cannot comment", triage.URL)
		return nil
	}

	baseURL := "https://sippy-auth.dptools.openshift.org"
	// If we have an Origin header, we can get the proper triage URL from it.
	// This is useful for local development, and future-proofing
	if origin := req.Header.Get("Origin"); origin != "" {
		if u, err := url.Parse(origin); err == nil {
			baseURL = u.Scheme + "://" + u.Host
		}
	}

	comment := fmt.Sprintf("This bug has been triaged to one or more component readiness regressions. More information can be found at: %s/sippy-ng/component_readiness/triages/%d", baseURL, triage.ID)
	_, response, err := jiraClient.Issue.AddComment(jiraCard, &jira.Comment{Body: comment})
	if err != nil {
		if response != nil {
			body, readErr := io.ReadAll(response.Body)
			if readErr != nil {
				logger.WithError(readErr).Errorf("error reading response body. original error is: %v", err)
			} else {
				logger.WithError(err).Errorf("error commenting on jira issue: %q", body)
			}
		}
		return fmt.Errorf("error commenting on Jira issue for triage record: %v", err)
	}

	return nil
}

func linkRegressions(dbc *gorm.DB, triage *models.Triage) error {
	// We support linking to regressions by just setting the ID in the request, lookup
	// full regressions for association.
	regressionIDs := []uint{}
	for _, trIDR := range triage.Regressions {
		regressionIDs = append(regressionIDs, trIDR.ID)
	}
	var linkedRegressions []models.TestRegression
	res := dbc.Where("id IN ?", regressionIDs).Find(&linkedRegressions)
	if res.Error != nil {
		log.WithError(res.Error).Errorf("error looking up regression IDs: %v", regressionIDs)
		return res.Error
	}

	if len(linkedRegressions) != len(regressionIDs) {
		missing := []uint{}
		for _, ri := range regressionIDs {
			var found bool
			for _, lr := range linkedRegressions {
				log.Infof("got lr : %+v", lr)
				if lr.ID == ri {
					found = true
					break
				}
			}
			if !found {
				missing = append(missing, ri)
			}
		}
		err := fmt.Errorf("some of the requested regression IDs were not found: %v",
			missing)
		log.WithError(err).Error("error looking up test regressions during create")
		return err
	}
	triage.Regressions = linkedRegressions
	return nil
}

func UpdateTriage(dbc *gorm.DB, jiraClient *jira.Client, triage models.Triage, req *http.Request) (models.Triage, error) {
	err := validateTriage(triage, true)
	if err != nil {
		log.WithError(err).Error("error validating triage record")
		return triage, err
	}

	// Ensure the record exists and preserve fields you're not allowed to update:
	// Side effect of not requiring you to specify them in your json.
	existingTriage := models.Triage{}
	res := dbc.First(&existingTriage, triage.ID)
	if res.Error != nil {
		log.WithError(res.Error).Errorf("error looking up existing triage record: %v", triage.ID)
		return triage, res.Error
	}
	triage.CreatedAt = existingTriage.CreatedAt

	err = linkRegressions(dbc, &triage)
	if err != nil {
		return triage, err
	}

	// If the resolution has been set/modified set the reason to "user"
	if existingTriage.Resolved.Time != triage.Resolved.Time {
		triage.ResolutionReason = models.User
	}
	// If the triage is unresolved, make sure the reason is unset
	if !triage.Resolved.Valid {
		triage.ResolutionReason = ""
	}

	// If we have a bug in the db matching the url we were given, link them up now.
	// If not, this should be handled later during the next fetchdata cron job.
	var bug models.Bug
	res = dbc.Where("url = ?", triage.URL).First(&bug)
	switch {
	case res.Error != nil && !errors.Is(res.Error, gorm.ErrRecordNotFound):
		log.WithError(res.Error).Errorf("unexpected error looking up bug: %s", triage.URL)
		return triage, res.Error
	case res.Error == nil:
		triage.Bug = &bug
		triage.BugID = &bug.ID
	}

	// Use a transaction to handle both model update and association changes atomically
	// Gorm is unable to handle this in a single save operation when regressions are removed
	err = dbc.Transaction(func(tx *gorm.DB) error {
		// Capture the old triage state before making any changes, this is necessary to avoid multiple audit logs for the transaction
		var oldTriage models.Triage
		if err := tx.Preload("Regressions").First(&oldTriage, triage.ID).Error; err != nil {
			return err
		}
		ctx := context.WithValue(tx.Statement.Context, models.OldTriageKey, oldTriage)
		txWithContext := tx.WithContext(ctx)

		if err := txWithContext.Session(&gorm.Session{SkipHooks: true}).Model(&triage).Association("Regressions").Replace(triage.Regressions); err != nil {
			return err
		}

		return txWithContext.Save(&triage).Error
	})
	if err != nil {
		log.WithError(err).Error("error updating triage record and associations")
		return triage, err
	}

	injectHATEOASLinks(&triage, sippyapi.GetBaseURL(req))

	// If the Jira URL has been updated, report on the new Jira
	if existingTriage.URL != triage.URL {
		err = reportJiraUsedForTriage(jiraClient, triage, req)
		if err != nil {
			log.WithError(err).Error("error reporting jira used for triage")
			return triage, err
		}
	}
	return triage, nil
}

func DeleteTriage(dbc *gorm.DB, id int) error {
	existingTriage := &models.Triage{}
	res := dbc.First(existingTriage, id).Delete(existingTriage)
	if res.Error != nil {
		return fmt.Errorf("error deleting triage record: %v", res.Error)
	}
	return nil
}

// ListRegressions lists all regressions for the provided view OR release
func ListRegressions(dbc *db.DB, view, release string, views []crview.View, releases []v1.Release, crTimeRoundingFactor time.Duration, req *http.Request) ([]models.TestRegression, error) {
	// TODO(sgoeddel): We should convert this into a response object that also contains the status.
	// Now that we have the test_details link, the status would allow us to stop returning the component_report regressed_tests in many (all) of these endpoints.
	var regressions []models.TestRegression
	var err error
	regressions, err = query.ListRegressions(dbc, view, release)
	if err != nil {
		return nil, err
	}

	// Add HATEOAS links to each regression
	for i := range regressions {
		InjectRegressionHATEOASLinks(&regressions[i], views, releases, crTimeRoundingFactor, sippyapi.GetBaseURL(req))
	}

	return regressions, err
}

// GetRegression returns the regression with the matching ID
func GetRegression(dbc *db.DB, id int, views []crview.View, releases []v1.Release, crTimeRoundingFactor time.Duration, req *http.Request) (*models.TestRegression, error) {
	regression := &models.TestRegression{}
	res := dbc.DB.Preload("Triages").First(regression, id)
	if res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		log.WithError(res.Error).Errorf("error looking up existing regression record: %d", id)
	} else {
		InjectRegressionHATEOASLinks(regression, views, releases, crTimeRoundingFactor, sippyapi.GetBaseURL(req))
	}
	return regression, res.Error
}

// GetTriagePotentialMatches returns a list of PotentialMatchingRegression including all possible matching regressions for a given
// triage, and componentReport. It calculates this based on similarly named tests being regressed, and regressions that
// have the same last failure time. It includes a confidence level for each match that states how likely the match is to be relevant.
func GetTriagePotentialMatches(triage *models.Triage, allRegressions []models.TestRegression, componentReport componentreport.ComponentReport, req *http.Request) ([]PotentialMatchingRegression, error) {
	var potentialMatches []PotentialMatchingRegression
	baseURL := sippyapi.GetBaseURL(req)
	for _, reg := range allRegressions {
		if reg.Closed.Valid {
			// Don't bother listing closed regressions as potential matches
			continue
		}
		regressedTest := GetMatchingRegressedTestForRegression(reg, componentReport)
		if regressedTest == nil {
			// This would only happen if the regression data in postgres is stale, and this regression has rolled off
			log.Warnf("no regression found for test %s, excluding", reg.TestID)
			continue
		}
		match := PotentialMatchingRegression{
			RegressedTest:  *regressedTest,
			PotentialMatch: determinePotentialMatch(reg, triage),
		}
		if match.PotentialMatch != nil {
			match.ConfidenceLevel = match.PotentialMatch.calculateConfidenceLevel()
			match.Links = map[string]string{
				"self":   fmt.Sprintf(potentialMatchesLink, baseURL, triage.ID),
				"triage": fmt.Sprintf(triageLink, baseURL, triage.ID),
			}
			potentialMatches = append(potentialMatches, match)
		}
	}

	return potentialMatches, nil
}

// determinePotentialMatch decides if the given regression has the potential to be associated with the given triage
func determinePotentialMatch(regression models.TestRegression, triage *models.Triage) *PotentialMatch {
	match := &PotentialMatch{}
	for _, tr := range triage.Regressions {
		if tr.ID == regression.ID {
			// if this regression is already associated with the triage, never list it as a potential match
			return nil
		}
		similarTestName, editDistance := isSimilarTestName(regression.TestName, tr.TestName)
		if similarTestName {
			match.SimilarlyNamedTests = append(match.SimilarlyNamedTests, SimilarlyNamedTest{
				Regression:   tr,
				EditDistance: editDistance,
			})
		}
		if isSameLastFailure(regression.LastFailure, tr.LastFailure) {
			match.SameLastFailures = append(match.SameLastFailures, tr)
		}
	}

	// If we haven't hit any matching criteria, there is no potential match
	if len(match.SimilarlyNamedTests) == 0 && len(match.SameLastFailures) == 0 {
		return nil
	}

	return match
}

// GetRegressionPotentialMatchingTriages returns a list of PotentialMatchingTriage including all possible matching triages for a given
// regression. It calculates this based on similarly named tests being regressed, and associated regressions that
// have the same last failure time. It includes a confidence level for each match that states how likely the match is to be relevant.
func GetRegressionPotentialMatchingTriages(regression models.TestRegression, triages []models.Triage, req *http.Request) ([]PotentialMatchingTriage, error) {
	var potentialMatches []PotentialMatchingTriage
	baseURL := sippyapi.GetBaseURL(req)
	for _, triage := range triages {
		// If the triage already contains the regression, don't consider it a potential match
		for _, reg := range triage.Regressions {
			if reg.ID == regression.ID {
				continue
			}
		}

		match := PotentialMatchingTriage{
			Triage:         triage,
			PotentialMatch: determinePotentialMatch(regression, &triage),
		}
		if match.PotentialMatch != nil {
			match.ConfidenceLevel = match.PotentialMatch.calculateConfidenceLevel()
			match.Links = map[string]string{
				"self":       fmt.Sprintf(potentialMatchingTriagesLink, baseURL, regression.ID),
				"regression": fmt.Sprintf(regressionLink, baseURL, regression.ID),
			}
			potentialMatches = append(potentialMatches, match)
		}
	}

	return potentialMatches, nil
}

type PotentialMatch struct {
	// SimilarlyNamedTests contains each of the already associated regressions that have a similar name, and their editDistance difference
	SimilarlyNamedTests []SimilarlyNamedTest `json:"similarly_named_tests"`
	// SameLastFailures contains each of the already associated regressions that have the same last failure time
	// This shows us that the regressions were found in the same job, indicating a higher likelihood of correlation.
	SameLastFailures []models.TestRegression `json:"same_last_failures"`
	// ConfidenceLevel is a number between 0-10 with a higher number being more likely to be a proper match
	ConfidenceLevel int `json:"confidence_level"`
	// Links include HATEOAS links to related resources
	Links map[string]string `json:"links"`
}

// calculateConfidenceLevel calculates confidence level (1-10) for a potential match
// based on the number and type of matches, with edit distance affecting name match scores
func (pm PotentialMatch) calculateConfidenceLevel() int {
	score := 0

	// Calculate score for similarly named tests based on edit distance
	for _, similarTest := range pm.SimilarlyNamedTests {
		editDistanceScore := 6 - similarTest.EditDistance // 1 point for 5 edit distance, 2 points for 4, etc.
		score += editDistanceScore
	}

	// Add 1 point for each same last failure match
	score += len(pm.SameLastFailures)

	if score > 10 {
		score = 10
	}
	// This should never happen, but we should never return a score less than 1
	if score < 1 {
		score = 1
	}

	return score
}

type PotentialMatchingRegression struct {
	*PotentialMatch
	// RegressedTest contains all the info about the potentially matching regression
	RegressedTest componentreport.ReportTestSummary `json:"regressed_test"`
}

type PotentialMatchingTriage struct {
	*PotentialMatch
	// Triage is the triage that this regression potentially matches
	Triage models.Triage `json:"triage"`
}

type SimilarlyNamedTest struct {
	Regression   models.TestRegression `json:"regression"`
	EditDistance int                   `json:"edit_distance"`
}

func GetMatchingRegressedTestForRegression(regression models.TestRegression, report componentreport.ComponentReport) *componentreport.ReportTestSummary {
	for _, row := range report.Rows {
		for _, column := range row.Columns {
			for _, regressedTest := range column.RegressedTests {
				if regressedTest.Regression != nil && regressedTest.Regression.ID == regression.ID {
					return &regressedTest
				}
			}
		}
	}

	return nil
}

// calculateEditDistance calculates the Levenshtein distance between two strings
func calculateEditDistance(s1, s2 string) int {
	if s1 == s2 {
		return 0
	}

	len1, len2 := len(s1), len(s2)
	if len1 == 0 {
		return len2
	}
	if len2 == 0 {
		return len1
	}

	// Create a matrix to store distances
	matrix := make([][]int, len1+1)
	for i := range matrix {
		matrix[i] = make([]int, len2+1)
	}

	// Initialize first row and column
	for i := 0; i <= len1; i++ {
		matrix[i][0] = i
	}
	for j := 0; j <= len2; j++ {
		matrix[0][j] = j
	}

	// Fill the matrix
	for i := 1; i <= len1; i++ {
		for j := 1; j <= len2; j++ {
			cost := 0
			if s1[i-1] != s2[j-1] {
				cost = 1
			}

			matrix[i][j] = min(
				matrix[i-1][j]+1,      // deletion
				matrix[i][j-1]+1,      // insertion
				matrix[i-1][j-1]+cost, // substitution
			)
		}
	}

	return matrix[len1][len2]
}

// isSimilarTestName checks if two test names are similar based on edit distance
// Returns true if the edit distance is 5 or less, false otherwise.
// It also returns the edit distance
func isSimilarTestName(testName1, testName2 string) (bool, int) {
	editDistance := calculateEditDistance(testName1, testName2)
	return editDistance <= 5, editDistance
}

// isSameLastFailure simply returns if the times are the same, including that they both have the same validity
func isSameLastFailure(time1, time2 sql.NullTime) bool {
	if !time1.Valid && !time2.Valid {
		return true
	}
	if time1.Valid != time2.Valid {
		return false
	}

	return time1.Time.Equal(time2.Time)
}

func getAuditLogsForTriageID(dbc *gorm.DB, triageID int) ([]models.AuditLog, error) {
	var auditLogs []models.AuditLog
	res := dbc.Where("table_name = 'triage' and row_id = ?", triageID).Order("created_at DESC").Find(&auditLogs)
	if res.Error != nil {
		return nil, res.Error
	}
	return auditLogs, nil
}

// TriageAuditLog represents an audit log with processed change data
type TriageAuditLog struct {
	Operation string        `json:"operation"`
	Changes   []FieldChange `json:"changes,omitempty"`
	User      string        `json:"user"`
	CreatedAt time.Time     `json:"created_at"`
	// Links include HATEOAS links to related resources
	Links map[string]string `json:"links"`
}

// FieldChange represents a change to a specific field
type FieldChange struct {
	FieldName string `json:"field_name"`
	Original  string `json:"original"`
	Modified  string `json:"modified"`
}

// newFieldChange creates a new FieldChange with the given parameters
func newFieldChange(fieldName, original, modified string) FieldChange {
	return FieldChange{
		FieldName: fieldName,
		Original:  original,
		Modified:  modified,
	}
}

// compareTriageObjects compares two Triage objects and returns a list of field changes.
// It only checks the fields that a user can change, and we care about.
func compareTriageObjects(oldTriage, newTriage *models.Triage) []FieldChange {
	var changes []FieldChange

	if oldTriage.URL != newTriage.URL {
		changes = append(changes, newFieldChange("url", oldTriage.URL, newTriage.URL))
	}

	if oldTriage.Description != newTriage.Description {
		changes = append(changes, newFieldChange("description", oldTriage.Description, newTriage.Description))
	}

	if oldTriage.Type != newTriage.Type {
		changes = append(changes, newFieldChange("type", string(oldTriage.Type), string(newTriage.Type)))
	}

	if oldTriage.Resolved != newTriage.Resolved {
		var oldResolved, newResolved string
		if oldTriage.Resolved.Valid {
			oldResolved = oldTriage.Resolved.Time.String()
		}
		if newTriage.Resolved.Valid {
			newResolved = newTriage.Resolved.Time.String()
		}

		changes = append(changes, newFieldChange("resolved", oldResolved, newResolved))
	}

	if oldTriage.ResolutionReason != newTriage.ResolutionReason {
		changes = append(changes, newFieldChange("resolution_reason", string(oldTriage.ResolutionReason), string(newTriage.ResolutionReason)))
	}

	var oldBugID, newBugID string
	if oldTriage.BugID != nil {
		oldBugID = fmt.Sprintf("%v", *oldTriage.BugID)
	}
	if newTriage.BugID != nil {
		newBugID = fmt.Sprintf("%v", *newTriage.BugID)
	}

	if oldBugID != newBugID {
		changes = append(changes, newFieldChange("bug_id", oldBugID, newBugID))
	}

	// Compare regressions by extracting just the IDs, and sorting them as order doesn't matter for comparison
	oldRegressionIDs := make([]uint, len(oldTriage.Regressions))
	for i, reg := range oldTriage.Regressions {
		oldRegressionIDs[i] = reg.ID
	}
	slices.Sort(oldRegressionIDs)

	newRegressionIDs := make([]uint, len(newTriage.Regressions))
	for i, reg := range newTriage.Regressions {
		newRegressionIDs[i] = reg.ID
	}
	slices.Sort(newRegressionIDs)

	if !slices.Equal(oldRegressionIDs, newRegressionIDs) {
		var oldRegressionsStr, newRegressionsStr string
		if len(oldRegressionIDs) > 0 {
			oldRegressionsStr = fmt.Sprintf("%v", oldRegressionIDs)
		}
		if len(newRegressionIDs) > 0 {
			newRegressionsStr = fmt.Sprintf("%v", newRegressionIDs)
		}
		changes = append(changes, newFieldChange("regressions", oldRegressionsStr, newRegressionsStr))
	}

	return changes
}

// GetTriageAuditDetails processes audit logs for a triage and returns response-ready audit log data
func GetTriageAuditDetails(dbc *gorm.DB, triageID int, req *http.Request) ([]TriageAuditLog, error) {
	auditLogs, err := getAuditLogsForTriageID(dbc, triageID)
	if err != nil {
		return nil, err
	}

	baseURL := sippyapi.GetBaseURL(req)
	var responseAuditLogs []TriageAuditLog
	for _, auditLog := range auditLogs {
		response := TriageAuditLog{
			Operation: auditLog.Operation,
			User:      auditLog.User,
			CreatedAt: auditLog.CreatedAt,
			Links: map[string]string{
				"self":   fmt.Sprintf(auditLogsLink, baseURL, triageID),
				"triage": fmt.Sprintf(triageLink, baseURL, triageID),
			},
		}

		switch models.OperationType(auditLog.Operation) {
		case models.Create:
			var newTriage models.Triage
			if err = json.Unmarshal(auditLog.NewData, &newTriage); err != nil {
				return nil, fmt.Errorf("error unmarshalling new data: %w", err)
			}
			response.Changes = compareTriageObjects(&models.Triage{}, &newTriage)
		case models.Delete:
			var oldTriage models.Triage
			if err = json.Unmarshal(auditLog.OldData, &oldTriage); err != nil {
				return nil, fmt.Errorf("error unmarshalling old data: %w", err)
			}
			response.Changes = compareTriageObjects(&oldTriage, &models.Triage{})
		case models.Update:
			var oldTriage, newTriage models.Triage
			if err = json.Unmarshal(auditLog.OldData, &oldTriage); err != nil {
				return nil, fmt.Errorf("error unmarshalling old data: %w", err)
			}
			if err = json.Unmarshal(auditLog.NewData, &newTriage); err != nil {
				return nil, fmt.Errorf("error unmarshalling new data: %w", err)
			}
			response.Changes = compareTriageObjects(&oldTriage, &newTriage)
		}

		responseAuditLogs = append(responseAuditLogs, response)
	}

	return responseAuditLogs, nil
}

const (
	triageLink           = "%s/api/component_readiness/triages/%d"
	potentialMatchesLink = "%s/api/component_readiness/triages/%d/matches"
	auditLogsLink        = "%s/api/component_readiness/triages/%d/audit"

	regressionLink               = "%s/api/component_readiness/regressions/%d"
	potentialMatchingTriagesLink = "%s/api/component_readiness/regressions/%d/matches"
)

// injectHATEOASLinks adds restful links clients can follow for this triage record.
func injectHATEOASLinks(triage *models.Triage, baseURL string) {
	triage.Links = map[string]string{
		"self":              fmt.Sprintf(triageLink, baseURL, triage.ID),
		"potential_matches": fmt.Sprintf(potentialMatchesLink, baseURL, triage.ID),
		"audit_logs":        fmt.Sprintf(auditLogsLink, baseURL, triage.ID),
	}
}

// InjectRegressionHATEOASLinks adds restful links clients can follow for this regression record.
func InjectRegressionHATEOASLinks(regression *models.TestRegression, views []crview.View, releases []v1.Release, crTimeRoundingFactor time.Duration, baseURL string) {
	if regression.Links == nil {
		regression.Links = make(map[string]string)
	}

	// Add self link with fully qualified URL using the correct protocol
	regression.Links["self"] = fmt.Sprintf(regressionLink, baseURL, regression.ID)

	// Generate test details URL - extract the required data from the regression and view
	testDetailsURL, err := generateTestDetailsURLFromRegression(regression, views, releases, crTimeRoundingFactor, baseURL)
	if err != nil {
		// This will result in a undefined link, if this is noticed we can search for this message in the logs and discover why
		log.WithError(err).Errorf("failed to generate test details URL for regression %d", regression.ID)
		return
	}

	regression.Links["test_details"] = testDetailsURL
}

// generateTestDetailsURLFromRegression extracts the required data from a regression and view
// and calls the GenerateTestDetailsURL function.
func generateTestDetailsURLFromRegression(regression *models.TestRegression, views []crview.View, releases []v1.Release, crTimeRoundingFactor time.Duration, baseURL string) (string, error) {
	if regression == nil {
		return "", fmt.Errorf("regression cannot be nil")
	}

	// Find the view for this regression
	var view crview.View
	var found bool
	for i := range views {
		if views[i].Name == regression.View {
			view = views[i]
			found = true
			break
		}
	}
	if !found {
		return "", fmt.Errorf("view %s not found", regression.View)
	}

	// Get base and sample release options from the view
	baseReleaseOpts, err := utils.GetViewReleaseOptions(releases, "basis", view.BaseRelease, crTimeRoundingFactor)
	if err != nil {
		return "", fmt.Errorf("failed to get base release options: %w", err)
	}

	sampleReleaseOpts, err := utils.GetViewReleaseOptions(releases, "sample", view.SampleRelease, crTimeRoundingFactor)
	if err != nil {
		return "", fmt.Errorf("failed to get sample release options: %w", err)
	}

	return utils.GenerateTestDetailsURL(
		regression.TestID,
		baseURL,
		baseReleaseOpts,
		sampleReleaseOpts,
		view.AdvancedOptions,
		view.VariantOptions,
		regression.Component,
		regression.Capability,
		regression.Variants,
		regression.BaseRelease,
	)
}
