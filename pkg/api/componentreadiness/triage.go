package componentreadiness

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"slices"
	"time"

	"github.com/openshift/sippy/pkg/apis/api/componentreport"
	"github.com/openshift/sippy/pkg/db"
	"github.com/openshift/sippy/pkg/db/models"
	"github.com/openshift/sippy/pkg/db/query"
	log "github.com/sirupsen/logrus"
	"gorm.io/gorm"
)

func GetTriage(dbc *db.DB, id int) (*models.Triage, error) {
	existingTriage := &models.Triage{}
	res := dbc.DB.Preload("Bug").Preload("Regressions").First(existingTriage, id)
	if res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		log.WithError(res.Error).Errorf("error looking up existing triage record: %d", id)
	}
	injectHATEOASLinks(existingTriage)
	return existingTriage, res.Error
}

func ListTriages(dbc *db.DB) ([]models.Triage, error) {
	var triages []models.Triage
	var err error
	triages, err = query.ListTriages(dbc)
	for i := range triages {
		injectHATEOASLinks(&triages[i])
	}
	return triages, err
}

// validateTriage ensures the Triage record coming into the API appears valid. Small
// changes in logic for create vs update are controlled by the update param.
func validateTriage(triage models.Triage, update bool) error {
	create := !update
	if create && triage.ID > 0 {
		return fmt.Errorf("cannot specify an id for a new triage record, one will be autogenerated")
	}
	if update && triage.ID == 0 {
		return fmt.Errorf("must specify an id for a triage record update")
	}
	if triage.URL == "" {
		return fmt.Errorf("url is required for a triage record")
	}
	if !models.ValidTriageType(triage.Type) {
		return fmt.Errorf("invalid triage type: %s", triage.Type)
	}

	return nil
}

func CreateTriage(dbc *gorm.DB, triage models.Triage) (models.Triage, error) {
	err := validateTriage(triage, false)
	if err != nil {
		log.WithError(err).Error("error validating triage record")
		return triage, err
	}
	// zero out the timestamps, you shouldn't be specifying them, but it's not worth erroring a request over
	triage.CreatedAt = time.Time{}
	triage.UpdatedAt = time.Time{}

	err = linkRegressions(dbc, &triage)
	if err != nil {
		return triage, err
	}

	// If we have a bug in the db matching the url we were given, link them up now.
	// If not, this should be handled later during the next fetchdata cron job.
	var bug models.Bug
	res := dbc.Where("url = ?", triage.URL).First(&bug)
	switch {
	case res.Error != nil && !errors.Is(res.Error, gorm.ErrRecordNotFound):
		log.WithError(res.Error).Errorf("unexpected error looking up bug: %s", triage.URL)
		return triage, res.Error
	case res.Error == nil:
		triage.Bug = &bug
		triage.BugID = &bug.ID
	}

	res = dbc.Create(&triage)
	if res.Error != nil {
		log.WithError(res.Error).Error("error creating triage record")
		return triage, res.Error
	}
	log.WithField("triageID", triage.ID).Info("triage record created")

	injectHATEOASLinks(&triage)
	return triage, nil
}

func linkRegressions(dbc *gorm.DB, triage *models.Triage) error {
	// We support linking to regressions by just setting the ID in the request, lookup
	// full regressions for association.
	regressionIDs := []uint{}
	for _, trIDR := range triage.Regressions {
		regressionIDs = append(regressionIDs, trIDR.ID)
	}
	var linkedRegressions []models.TestRegression
	res := dbc.Where("id IN ?", regressionIDs).Find(&linkedRegressions)
	if res.Error != nil {
		log.WithError(res.Error).Errorf("error looking up regression IDs: %v", regressionIDs)
		return res.Error
	}

	if len(linkedRegressions) != len(regressionIDs) {
		missing := []uint{}
		for _, ri := range regressionIDs {
			var found bool
			for _, lr := range linkedRegressions {
				log.Infof("got lr : %+v", lr)
				if lr.ID == ri {
					found = true
					break
				}
			}
			if !found {
				missing = append(missing, ri)
			}
		}
		err := fmt.Errorf("some of the requested regression IDs were not found: %v",
			missing)
		log.WithError(err).Error("error looking up test regressions during create")
		return err
	}
	triage.Regressions = linkedRegressions
	return nil
}

func UpdateTriage(dbc *gorm.DB, triage models.Triage) (models.Triage, error) {
	err := validateTriage(triage, true)
	if err != nil {
		log.WithError(err).Error("error validating triage record")
		return triage, err
	}

	// Ensure the record exists and preserve fields you're not allowed to update:
	// Side effect of not requiring you to specify them in your json.
	existingTriage := models.Triage{}
	res := dbc.First(&existingTriage, triage.ID)
	if res.Error != nil {
		log.WithError(res.Error).Errorf("error looking up existing triage record: %v", triage.ID)
		return triage, res.Error
	}
	triage.CreatedAt = existingTriage.CreatedAt

	err = linkRegressions(dbc, &triage)
	if err != nil {
		return triage, err
	}

	// If we have a bug in the db matching the url we were given, link them up now.
	// If not, this should be handled later during the next fetchdata cron job.
	var bug models.Bug
	res = dbc.Where("url = ?", triage.URL).First(&bug)
	switch {
	case res.Error != nil && !errors.Is(res.Error, gorm.ErrRecordNotFound):
		log.WithError(res.Error).Errorf("unexpected error looking up bug: %s", triage.URL)
		return triage, res.Error
	case res.Error == nil:
		triage.Bug = &bug
		triage.BugID = &bug.ID
	}

	// Use a transaction to handle both model update and association changes atomically
	// Gorm is unable to handle this in a single save operation when regressions are removed
	err = dbc.Transaction(func(tx *gorm.DB) error {
		// Capture the old triage state before making any changes, this is necessary to avoid multiple audit logs for the transaction
		var oldTriage models.Triage
		if err := tx.Preload("Regressions").First(&oldTriage, triage.ID).Error; err != nil {
			return err
		}
		ctx := context.WithValue(tx.Statement.Context, models.OldTriageKey, oldTriage)
		txWithContext := tx.WithContext(ctx)

		if err := txWithContext.Session(&gorm.Session{SkipHooks: true}).Model(&triage).Association("Regressions").Replace(triage.Regressions); err != nil {
			return err
		}

		return txWithContext.Save(&triage).Error
	})
	if err != nil {
		log.WithError(err).Error("error updating triage record and associations")
		return triage, err
	}

	injectHATEOASLinks(&triage)
	return triage, nil
}

func DeleteTriage(dbc *gorm.DB, id int) error {
	existingTriage := &models.Triage{}
	res := dbc.First(existingTriage, id).Delete(existingTriage)
	if res.Error != nil {
		return fmt.Errorf("error deleting triage record: %v", res.Error)
	}
	return nil
}

// GetRegressions returns all regressions for the provided view
func GetRegressions(dbc *gorm.DB, view string) ([]models.TestRegression, error) {
	var regressions []models.TestRegression
	res := dbc.Preload("Triages").Where("view = ?", view).Find(&regressions)
	if res.Error != nil {
		return nil, res.Error
	}
	return regressions, nil
}

// GetRegression returns the regression with the matching ID
func GetRegression(dbc *gorm.DB, id int) (*models.TestRegression, error) {
	var regression models.TestRegression
	res := dbc.Preload("Triages").First(&regression, id)
	if res.Error != nil {
		return nil, res.Error
	}
	return &regression, nil
}

// GetTriagePotentialMatches returns a list of PotentialMatchingRegression including all possible matching regressions for a given
// triage, and componentReport. It calculates this based on similarly named tests being regressed, and regressions that
// have the same last failure time. It includes a confidence level for each match that states how likely the match is to be relevant.
func GetTriagePotentialMatches(triage *models.Triage, allRegressions []models.TestRegression, componentReport componentreport.ComponentReport) ([]PotentialMatchingRegression, error) {
	var potentialMatches []PotentialMatchingRegression
	for _, reg := range allRegressions {
		if reg.Closed.Valid {
			// Don't bother listing closed regressions as potential matches
			continue
		}
		regressedTest := GetMatchingRegressedTestForRegression(reg, componentReport)
		if regressedTest == nil {
			// This would only happen if the regression data in postgres is stale, and this regression has rolled off
			log.Warnf("no regression found for test %s, excluding", reg.TestID)
			continue
		}
		match := PotentialMatchingRegression{
			RegressedTest:  *regressedTest,
			PotentialMatch: determinePotentialMatch(reg, triage),
		}
		if match.PotentialMatch != nil {
			match.ConfidenceLevel = match.PotentialMatch.calculateConfidenceLevel()
			match.Links = map[string]string{
				"self":   fmt.Sprintf(potentialMatchesLink, triage.ID),
				"triage": fmt.Sprintf(triageLink, triage.ID),
			}
			potentialMatches = append(potentialMatches, match)
		}
	}

	return potentialMatches, nil
}

// determinePotentialMatch decides if the given regression has the potential to be associated with the given triage
func determinePotentialMatch(regression models.TestRegression, triage *models.Triage) *PotentialMatch {
	match := &PotentialMatch{}
	for _, tr := range triage.Regressions {
		if tr.ID == regression.ID {
			// if this regression is already associated with the triage, never list it as a potential match
			return nil
		}
		similarTestName, editDistance := isSimilarTestName(regression.TestName, tr.TestName)
		if similarTestName {
			match.SimilarlyNamedTests = append(match.SimilarlyNamedTests, SimilarlyNamedTest{
				Regression:   tr,
				EditDistance: editDistance,
			})
		}
		if isSameLastFailure(regression.LastFailure, tr.LastFailure) {
			match.SameLastFailures = append(match.SameLastFailures, tr)
		}
	}

	// If we haven't hit any matching criteria, there is no potential match
	if len(match.SimilarlyNamedTests) == 0 && len(match.SameLastFailures) == 0 {
		return nil
	}

	return match
}

// GetRegressionPotentialMatches returns a list of PotentialMatchingTriage including all possible matching triages for a given
// regression. It calculates this based on similarly named tests being regressed, and associated regressions that
// have the same last failure time. It includes a confidence level for each match that states how likely the match is to be relevant.
func GetRegressionPotentialMatches(regression models.TestRegression, triages []models.Triage) ([]PotentialMatchingTriage, error) {
	var potentialMatches []PotentialMatchingTriage
	for _, triage := range triages {
		// If the triage already contains the regression, don't consider it a potential match
		for _, reg := range triage.Regressions {
			if reg.ID == regression.ID {
				continue
			}
		}

		match := PotentialMatchingTriage{
			Triage:         triage,
			PotentialMatch: determinePotentialMatch(regression, &triage),
		}
		if match.PotentialMatch != nil {
			match.ConfidenceLevel = match.PotentialMatch.calculateConfidenceLevel()
			match.Links = map[string]string{
				"self": fmt.Sprintf(potentialMatchingTriagesLink, triage.ID),
			}
			potentialMatches = append(potentialMatches, match)
		}
	}

	return potentialMatches, nil
}

type PotentialMatch struct {
	// SimilarlyNamedTests contains each of the already associated regressions that have a similar name, and their editDistance difference
	SimilarlyNamedTests []SimilarlyNamedTest `json:"similarly_named_tests"`
	// SameLastFailures contains each of the already associated regressions that have the same last failure time
	SameLastFailures []models.TestRegression `json:"same_last_failures"`
	// ConfidenceLevel is a number between 0-10 with a higher number being more likely to be a proper match
	ConfidenceLevel int `json:"confidence_level"`
	// Links include HATEOAS links to related resources
	Links map[string]string `json:"links"`
}

// calculateConfidenceLevel calculates confidence level (1-10) for a potential match
// based on the number and type of matches, with edit distance affecting name match scores
func (pm PotentialMatch) calculateConfidenceLevel() int {
	score := 0

	// Calculate score for similarly named tests based on edit distance
	for _, similarTest := range pm.SimilarlyNamedTests {
		editDistanceScore := 5 - similarTest.EditDistance // 0->5, 1->4, 2->3, 3->2, 4->1, 5->0
		score += editDistanceScore
	}

	// Add 1 point for each same last failure match
	score += len(pm.SameLastFailures)

	if score > 10 {
		score = 10
	}

	return score
}

type PotentialMatchingRegression struct {
	*PotentialMatch
	// RegressedTest contains all the info about the potentially matching regression
	RegressedTest componentreport.ReportTestSummary `json:"regressed_test"`
}

type PotentialMatchingTriage struct {
	*PotentialMatch
	// Triage is the triage that this regression potentially matches
	Triage models.Triage `json:"triage"`
}

type SimilarlyNamedTest struct {
	Regression   models.TestRegression `json:"regression"`
	EditDistance int                   `json:"edit_distance"`
}

func GetMatchingRegressedTestForRegression(regression models.TestRegression, report componentreport.ComponentReport) *componentreport.ReportTestSummary {
	for _, row := range report.Rows {
		for _, column := range row.Columns {
			for _, regressedTest := range column.RegressedTests {
				if regressedTest.Regression != nil && regressedTest.Regression.ID == regression.ID {
					return &regressedTest
				}
			}
		}
	}

	return nil
}

// calculateEditDistance calculates the Levenshtein distance between two strings
func calculateEditDistance(s1, s2 string) int {
	if s1 == s2 {
		return 0
	}

	len1, len2 := len(s1), len(s2)
	if len1 == 0 {
		return len2
	}
	if len2 == 0 {
		return len1
	}

	// Create a matrix to store distances
	matrix := make([][]int, len1+1)
	for i := range matrix {
		matrix[i] = make([]int, len2+1)
	}

	// Initialize first row and column
	for i := 0; i <= len1; i++ {
		matrix[i][0] = i
	}
	for j := 0; j <= len2; j++ {
		matrix[0][j] = j
	}

	// Fill the matrix
	for i := 1; i <= len1; i++ {
		for j := 1; j <= len2; j++ {
			cost := 0
			if s1[i-1] != s2[j-1] {
				cost = 1
			}

			matrix[i][j] = min(
				matrix[i-1][j]+1,      // deletion
				matrix[i][j-1]+1,      // insertion
				matrix[i-1][j-1]+cost, // substitution
			)
		}
	}

	return matrix[len1][len2]
}

// isSimilarTestName checks if two test names are similar based on edit distance
// Returns true if the edit distance is 5 or less, false otherwise.
// It also returns the edit distance
func isSimilarTestName(testName1, testName2 string) (bool, int) {
	editDistance := calculateEditDistance(testName1, testName2)
	return editDistance <= 5, editDistance
}

// isSameLastFailure simply returns if the times are the same, including that they both have the same validity
func isSameLastFailure(time1, time2 sql.NullTime) bool {
	if !time1.Valid && !time2.Valid {
		return true
	}
	if time1.Valid != time2.Valid {
		return false
	}

	return time1.Time.Equal(time2.Time)
}

func getAuditLogsForTriageID(dbc *gorm.DB, triageID int) ([]models.AuditLog, error) {
	var auditLogs []models.AuditLog
	res := dbc.Where("table_name = 'triage' and row_id = ?", triageID).Order("created_at DESC").Find(&auditLogs)
	if res.Error != nil {
		return nil, res.Error
	}
	return auditLogs, nil
}

// TriageAuditLog represents an audit log with processed change data
type TriageAuditLog struct {
	Operation string        `json:"operation"`
	Changes   []FieldChange `json:"changes,omitempty"`
	User      string        `json:"user"`
	CreatedAt time.Time     `json:"created_at"`
	// Links include HATEOAS links to related resources
	Links map[string]string `json:"links"`
}

// FieldChange represents a change to a specific field
type FieldChange struct {
	FieldName string `json:"field_name"`
	Original  string `json:"original"`
	Modified  string `json:"modified"`
}

// newFieldChange creates a new FieldChange with the given parameters
func newFieldChange(fieldName, original, modified string) FieldChange {
	return FieldChange{
		FieldName: fieldName,
		Original:  original,
		Modified:  modified,
	}
}

// compareTriageObjects compares two Triage objects and returns a list of field changes.
// It only checks the fields that a user can change, and we care about.
func compareTriageObjects(oldTriage, newTriage *models.Triage) []FieldChange {
	var changes []FieldChange

	if oldTriage.URL != newTriage.URL {
		changes = append(changes, newFieldChange("url", oldTriage.URL, newTriage.URL))
	}

	if oldTriage.Description != newTriage.Description {
		changes = append(changes, newFieldChange("description", oldTriage.Description, newTriage.Description))
	}

	if oldTriage.Type != newTriage.Type {
		changes = append(changes, newFieldChange("type", string(oldTriage.Type), string(newTriage.Type)))
	}

	if oldTriage.Resolved != newTriage.Resolved {
		var oldResolved, newResolved string
		if oldTriage.Resolved.Valid {
			oldResolved = oldTriage.Resolved.Time.String()
		}
		if newTriage.Resolved.Valid {
			newResolved = newTriage.Resolved.Time.String()
		}

		changes = append(changes, newFieldChange("resolved", oldResolved, newResolved))
	}

	var oldBugID, newBugID string
	if oldTriage.BugID != nil {
		oldBugID = fmt.Sprintf("%v", *oldTriage.BugID)
	}
	if newTriage.BugID != nil {
		newBugID = fmt.Sprintf("%v", *newTriage.BugID)
	}

	if oldBugID != newBugID {
		changes = append(changes, newFieldChange("bug_id", oldBugID, newBugID))
	}

	// Compare regressions by extracting just the IDs, and sorting them as order doesn't matter for comparison
	oldRegressionIDs := make([]uint, len(oldTriage.Regressions))
	for i, reg := range oldTriage.Regressions {
		oldRegressionIDs[i] = reg.ID
	}
	slices.Sort(oldRegressionIDs)

	newRegressionIDs := make([]uint, len(newTriage.Regressions))
	for i, reg := range newTriage.Regressions {
		newRegressionIDs[i] = reg.ID
	}
	slices.Sort(newRegressionIDs)

	if !slices.Equal(oldRegressionIDs, newRegressionIDs) {
		var oldRegressionsStr, newRegressionsStr string
		if len(oldRegressionIDs) > 0 {
			oldRegressionsStr = fmt.Sprintf("%v", oldRegressionIDs)
		}
		if len(newRegressionIDs) > 0 {
			newRegressionsStr = fmt.Sprintf("%v", newRegressionIDs)
		}
		changes = append(changes, newFieldChange("regressions", oldRegressionsStr, newRegressionsStr))
	}

	return changes
}

// GetTriageAuditDetails processes audit logs for a triage and returns response-ready audit log data
func GetTriageAuditDetails(dbc *gorm.DB, triageID int) ([]TriageAuditLog, error) {
	auditLogs, err := getAuditLogsForTriageID(dbc, triageID)
	if err != nil {
		return nil, err
	}

	var responseAuditLogs []TriageAuditLog
	for _, auditLog := range auditLogs {
		response := TriageAuditLog{
			Operation: auditLog.Operation,
			User:      auditLog.User,
			CreatedAt: auditLog.CreatedAt,
			Links: map[string]string{
				"self":   fmt.Sprintf(auditLogsLink, triageID),
				"triage": fmt.Sprintf(triageLink, triageID),
			},
		}

		switch models.OperationType(auditLog.Operation) {
		case models.Create:
			var newTriage models.Triage
			if err = json.Unmarshal(auditLog.NewData, &newTriage); err != nil {
				return nil, fmt.Errorf("error unmarshalling new data: %w", err)
			}
			response.Changes = compareTriageObjects(&models.Triage{}, &newTriage)
		case models.Delete:
			var oldTriage models.Triage
			if err = json.Unmarshal(auditLog.OldData, &oldTriage); err != nil {
				return nil, fmt.Errorf("error unmarshalling old data: %w", err)
			}
			response.Changes = compareTriageObjects(&oldTriage, &models.Triage{})
		case models.Update:
			var oldTriage, newTriage models.Triage
			if err = json.Unmarshal(auditLog.OldData, &oldTriage); err != nil {
				return nil, fmt.Errorf("error unmarshalling old data: %w", err)
			}
			if err = json.Unmarshal(auditLog.NewData, &newTriage); err != nil {
				return nil, fmt.Errorf("error unmarshalling new data: %w", err)
			}
			response.Changes = compareTriageObjects(&oldTriage, &newTriage)
		}

		responseAuditLogs = append(responseAuditLogs, response)
	}

	return responseAuditLogs, nil
}

const (
	triageLink           = "/api/component_readiness/triages/%d"
	potentialMatchesLink = "/api/component_readiness/triages/%d/matches"
	auditLogsLink        = "/api/component_readiness/triages/%d/audit"

	potentialMatchingTriagesLink = "/api/component_readiness/regressions/%d/matches"
)

// injectHATEOASLinks adds restful links clients can follow for this triage record.
func injectHATEOASLinks(triage *models.Triage) {
	triage.Links = map[string]string{
		"self":              fmt.Sprintf(triageLink, triage.ID),
		"potential_matches": fmt.Sprintf(potentialMatchesLink, triage.ID),
		"audit_logs":        fmt.Sprintf(auditLogsLink, triage.ID),
	}
}
